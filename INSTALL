#!/usr/bin/env python
import os
import shutil

# a list of files that we don't install (symlink) like everything else
blacklist = [
    '.DS_Store',
    '.git',
    '.gitignore',
    # ipython is kind of weird right now,
    # since we only care about a single file
    'ipython',
    'INSTALL',
    'README.md',
    'localrc',
    'new_mac.sh']

# here = os.path.dirname(__file__) or os.curdir
here = os.path.abspath(os.path.dirname(__file__))


class FSHelper(object):
    def __init__(self, dry_run, trash):
        self.dry_run = dry_run
        self.trash = self.mkdir_p(trash)
        # see if we have access to the specified trash path
        if not self.test_access(self.trash):
            raise Exception('Cannot proceed without access to a trash directory')

    def system(self, command):
        print command
        if not self.dry_run:
            os.system(command)

    # single file manipulation

    def mkdir_p(self, path):
        print 'mkdir -p %s' % path
        if not self.dry_run:
            if not os.path.exists(path):
                os.makedirs(path)
        return path

    def touch(self, path):
        print 'touch %s' % path
        if not self.dry_run:
            with open(path, 'w') as fd:
                # fd.write('Write access granted. This file can be safely deleted.')
                fd.write('')
        return path

    def remove(self, path, trash=True):
        if self.dry_run:
            print 'rm %s' % path
        elif os.path.islink(path):
            # display the resolution of the symlink before removing it
            print 'rm %s  # was -> %s' % (path, os.path.realpath(path))
            # if path is a broken symlink, os.path.islink(path) will be True, but
            # os.path.exists(path) will be False, which seems kind of strange.
            os.remove(path)
        elif not os.path.exists(path):
            return
        elif trash:
            filename = os.path.basename(path)
            path_in_trash = os.path.join(self.trash, filename)
            print 'trashing %s' % path
            self.move(path, path_in_trash)
        else:
            print 'rm %s' % path
            os.remove(path)

    def test_access(self, dirpath):
        '''Returns true if the directory exists / can be created and we have write access'''
        try:
            test_filepath = self.touch(os.path.join(dirpath, 'dummy.txt'))
            self.remove(test_filepath, trash=False)
            return True
        except Exception, exc:
            print exc
            return False

    # input/output file manipulation

    def move(self, source, target):
        print 'mv %s %s' % (source, target)
        if not self.dry_run:
            shutil.move(source, target)

    def copy(self, source, target):
        print 'cp %s %s' % (source, target)
        if not self.dry_run:
            shutil.copy(source, target)

    def symlink(self, source, target, relativize=False):
        '''
        The source file should already exist.
        The target file is what you're creating.

        Works like POSIX:

            ln [-Ffhinsv] source_file [target_file]
        '''
        if relativize:
            # evaluate the source path relative to the link path
            source = os.path.relpath(source, target)
        print 'ln -s %s %s' % (source, target)
        self.mkdir_p(os.path.dirname(target))
        if not self.dry_run:
            os.symlink(source, target)

    # other handy things

    def git_clone(self, url, target):
        if not os.path.exists(target):
            self.system('git clone %s %s' % (url, target))
        else:
            print '%s already exists; not cloning' % target


def main():
    import argparse
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description='Symlink version controlled dotfiles into home directory')
    parser.add_argument('-n', '--dry-run', action='store_true',
        help='Do not create, move, or delete anything')
    parser.add_argument('-s', '--source', default=here,
        help='Source directory')
    parser.add_argument('-d', '--destination', default=os.path.expanduser('~'),
        help='Destination directory')
    parser.add_argument('-l', '--local-rc', default='.localrc',
        help='Name of local rc file')
    parser.add_argument('-b', '--scripts', default='~/bin',
        help='Scripts path')
    parser.add_argument('-t', '--trash', default='/tmp/dotfiles.old',
        help='Trash directory')
    opts = parser.parse_args()

    fs = FSHelper(opts.dry_run, opts.trash)

    links = [filename for filename in os.listdir(opts.source) if filename not in blacklist]
    for filename in links:
        source_filepath = os.path.join(opts.source, filename)
        target_filepath = os.path.join(opts.destination, '.' + filename)
        print '[linking %s]' % target_filepath

        fs.remove(target_filepath)
        fs.symlink(source_filepath, target_filepath, relativize=False)

    # copy localrc to ~/.localrc for machine-specific configuration
    print '[installing .localrc]'
    local_rc_filepath = os.path.join(opts.destination, opts.local_rc)
    if not os.path.exists(local_rc_filepath):
        source_filepath = os.path.join(opts.source, 'localrc')
        fs.copy(source_filepath, local_rc_filepath)
    else:
        print 'localrc exists: %s; not replacing' % local_rc_filepath

    # link ~/.ipython/profile_default/ipython_config.py
    print '[linking ipython config]'
    local_ipython_config = 'ipython/profile_default/ipython_config.py'
    ipython_config_source_filepath = os.path.join(opts.source, local_ipython_config)
    ipython_config_target_filepath = os.path.join(opts.destination, '.' + local_ipython_config)
    fs.remove(ipython_config_target_filepath)
    fs.symlink(ipython_config_source_filepath, ipython_config_target_filepath, relativize=False)

    # install scripts to ~/bin if ~/bin does not exist
    home_bin = os.path.expanduser(opts.scripts)
    fs.git_clone('git://github.com/chbrown/scripts.git', home_bin)


if __name__ == '__main__':
    main()
